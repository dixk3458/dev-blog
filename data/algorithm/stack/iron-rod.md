# 쇠막대기

### :star: 문제 추상화

- 쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다.
- 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.
- 각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.
- 레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다.
- 레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ()으로 표현
- 쇠막대기의 왼쪽 끝은 여는 괄호 ( 로 , 오른쪽 끝은 닫힌 괄호 ) 로 표현한다.
- 입력으로 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구해라

<br>

### :wrench: 알고리즘 설계

- 쇠막대기의 개수를 저장할 변수 answer를 0으로 초기화한다.
- 작업중인 쇠막대기를 저장할 Stack을 생성한다.
- 문자열을 순회하면서 쇠막대기의 위치와 레이저의 위치를 조사한다.
- 현재 인덱스번호의 문자가 ( 일때 다음 문자가 )라면 레이저인것이다.
- 아니라면 새로운 막대기가 위에 쌓인것이다.
- 새로운 막대기가 위에 쌓이면, Stack에 push를 해준다.
- 레이저가 나오면 현재 Stack의 길이만큼 answer를 증가시킨다. 그리고 반복문 제어 변수를 1증가 시킨다.
- 현재 인덱스 번호가 ) 라면 쇠막대기가 끝난것이므로 Stack에서 pop()을 해준다.
- pop()을 하고 잘려진 막대를 넣는것을 잊지 말자.

<br>

### :hammer: 알고리즘 구현

```js
function solution(str) {
  let answer = 0;

  const stack = [];

  for (let i = 0; i < str.length; i++) {
    if (str[i] === '(') {
      if (str[i + 1] === '(') {
        stack.push(str[i]);
      } else {
        // 레이저
        answer = answer + stack.length;
        i = i + 1;
      }
    } else {
      // 쇠막대기 끝
      stack.pop();
      answer = answer + 1;
    }
  }

  return answer;
}

let a = '()(((()())(())()))(())';
console.log(solution(a));
```

<br>

### ✅ 검증 및 트러블 슈팅

- 정답
