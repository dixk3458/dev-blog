# ë°°ë‹¬

Nê°œì˜ ë§ˆì„ë¡œ ì´ë£¨ì–´ì§„ ë‚˜ë¼ê°€ ìˆìŠµë‹ˆë‹¤. ì´ ë‚˜ë¼ì˜ ê° ë§ˆì„ì—ëŠ” 1ë¶€í„° Nê¹Œì§€ì˜ ë²ˆí˜¸ê°€ ê°ê° í•˜ë‚˜ì”© ë¶€ì—¬ë˜ì–´ ìˆìŠµë‹ˆë‹¤. ê° ë§ˆì„ì€ ì–‘ë°©í–¥ìœ¼ë¡œ í†µí–‰í•  ìˆ˜ ìˆëŠ” ë„ë¡œë¡œ ì—°ê²°ë˜ì–´ ìˆëŠ”ë°, ì„œë¡œ ë‹¤ë¥¸ ë§ˆì„ ê°„ì— ì´ë™í•  ë•ŒëŠ” ì´ ë„ë¡œë¥¼ ì§€ë‚˜ì•¼ í•©ë‹ˆë‹¤. ë„ë¡œë¥¼ ì§€ë‚  ë•Œ ê±¸ë¦¬ëŠ” ì‹œê°„ì€ ë„ë¡œë³„ë¡œ ë‹¤ë¦…ë‹ˆë‹¤. í˜„ì¬ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì—ì„œ ê° ë§ˆì„ë¡œ ìŒì‹ ë°°ë‹¬ì„ í•˜ë ¤ê³  í•©ë‹ˆë‹¤. ê° ë§ˆì„ë¡œë¶€í„° ìŒì‹ ì£¼ë¬¸ì„ ë°›ìœ¼ë ¤ê³  í•˜ëŠ”ë°, Nê°œì˜ ë§ˆì„ ì¤‘ì—ì„œ K ì‹œê°„ ì´í•˜ë¡œ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ë§ˆì„ì—ì„œë§Œ ì£¼ë¬¸ì„ ë°›ìœ¼ë ¤ê³  í•©ë‹ˆë‹¤. ë‹¤ìŒì€ N = 5, K = 3ì¸ ê²½ìš°ì˜ ì˜ˆì‹œì…ë‹ˆë‹¤.

![img](https://grepp-programmers.s3.ap-northeast-2.amazonaws.com/files/production/d7779d88-084c-4ffa-ae9f-2a42f97d3bbf/%E1%84%87%E1%85%A2%E1%84%83%E1%85%A1%E1%86%AF_1_uxun8t.png)

ìœ„ ê·¸ë¦¼ì—ì„œ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì€ [1, 2, 4, 5] ë²ˆ ë§ˆì„ê¹Œì§€ëŠ” 3 ì´í•˜ì˜ ì‹œê°„ì— ë°°ë‹¬í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤. ê·¸ëŸ¬ë‚˜ 3ë²ˆ ë§ˆì„ê¹Œì§€ëŠ” 3ì‹œê°„ ì´ë‚´ë¡œ ë°°ë‹¬í•  ìˆ˜ ìˆëŠ” ê²½ë¡œê°€ ì—†ìœ¼ë¯€ë¡œ 3ë²ˆ ë§ˆì„ì—ì„œëŠ” ì£¼ë¬¸ì„ ë°›ì§€ ì•ŠìŠµë‹ˆë‹¤. ë”°ë¼ì„œ 1ë²ˆ ë§ˆì„ì— ìˆëŠ” ìŒì‹ì ì´ ë°°ë‹¬ ì£¼ë¬¸ì„ ë°›ì„ ìˆ˜ ìˆëŠ” ë§ˆì„ì€ 4ê°œê°€ ë©ë‹ˆë‹¤.

ë§ˆì„ì˜ ê°œìˆ˜ N, ê° ë§ˆì„ì„ ì—°ê²°í•˜ëŠ” ë„ë¡œì˜ ì •ë³´ road, ìŒì‹ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ì‹œê°„ Kê°€ ë§¤ê°œë³€ìˆ˜ë¡œ ì£¼ì–´ì§ˆ ë•Œ, ìŒì‹ ì£¼ë¬¸ì„ ë°›ì„ ìˆ˜ ìˆëŠ” ë§ˆì„ì˜ ê°œìˆ˜ë¥¼ return í•˜ë„ë¡ solution í•¨ìˆ˜ë¥¼ ì™„ì„±í•´ì£¼ì„¸ìš”.

### ë¬¸ì œ ì¶”ìƒí™” â­

ê° ë§ˆì„ì— ë°°ë‹¬ì„ í•˜ëŠ”ë°, Kì‹œê°„ ì´í•˜ë¡œ ë°°ë‹¬ì´ ê°€ëŠ¥í•œ ë§ˆì„ì€ ëª‡ê°œì¸ì§€ ë°˜í™˜í•˜ëŠ” ë¬¸ì œì´ë‹¤.

### ì „ëµ ğŸ”§

1. ê°€ì¤‘ì¹˜ ê·¸ë˜í”„ë¥¼ êµ¬í˜„í•˜ì.
2. ì¸ì ‘ ë¦¬ìŠ¤íŠ¸ë¥¼ ì´ìš©í•´ ê·¸ë˜í”„ë¥¼ ìƒì„±
3. ê° ë§ˆì„ë§ˆë‹¤ 1ë²ˆ ë§ˆì„ì—ì„œ ì‹œì‘í•´ ë„ì°©í•˜ëŠ” ìµœë‹¨ ê±°ë¦¬ë¥¼ ì¡°ì‚¬í•˜ì.
4. ê° ë§ˆì„ì˜ ìµœë‹¨ê±°ë¦¬ë¥¼ ì €ì¥í•  ë°°ì—´ distanceë¥¼ ìƒì„±í•œë‹¤.
5. ê°€ì¤‘ì¹˜ê°€ ì¡´ì¬í•˜ê¸°ì— ë‹¤ìµìŠ¤íŠ¸ë¼ë¥¼ ì´ìš©í•˜ì.
6. distanceì¤‘ì— Kì‹œê°„ ì´í•˜ì¸ ë§ˆì„ì˜ ê°œìˆ˜ë¥¼ ë°˜í™˜í•œë‹¤.

### êµ¬í˜„ ğŸ”¨

```jsx
class MinHeap {
  constructor() {
    this.heap = [null];
  }

  push(value) {
    this.heap.push(value);
    let currentIndex = this.heap.length - 1;
    let parentIndex = Math.floor(currentIndex / 2);

    while (parentIndex !== 0 && this.heap[parentIndex].cost > value.cost) {
      this._swap(parentIndex, currentIndex);

      currentIndex = parentIndex;
      parentIndex = Math.floor(currentIndex / 2);
    }
  }

  pop() {
    if (this.isEmpty()) return;
    if (this.heap.length === 2) return this.heap.pop();

    const returnValue = this.heap[1];
    this.heap[1] = this.heap.pop();

    let currentIndex = 1;
    let leftIndex = 2;
    let rightIndex = 3;
    while (
      (this.heap[leftIndex] &&
        this.heap[currentIndex].cost > this.heap[leftIndex].cost) ||
      (this.heap[rightIndex] &&
        this.heap[currentIndex].cost > this.heap[rightIndex].cost)
    ) {
      if (this.heap[leftIndex] === undefined) {
        // ì™¼ìª½ ì •ì ì´ ì—†ì„ ê²½ìš°
        this._swap(rightIndex, currentIndex);
      } else if (this.heap[rightIndex] === undefined) {
        // ì˜¤ë¥¸ìª½ ì •ì ì´ ì—†ì„ ê²½ìš°
        this._swap(leftIndex, currentIndex);
      } else if (this.heap[leftIndex].cost > this.heap[rightIndex].cost) {
        this._swap(rightIndex, currentIndex);
      } else if (this.heap[leftIndex].cost <= this.heap[rightIndex].cost) {
        this._swap(leftIndex, currentIndex);
      }
      leftIndex = currentIndex * 2;
      rightIndex = currentIndex * 2 + 1;
    }

    return returnValue;
  }

  isEmpty() {
    return this.heap.length === 1;
  }

  _swap(a, b) {
    // í¸ì˜ë¥¼ ìœ„í•´ ë°°ì—´ì˜ ìš”ì†Œë¥¼ swapí•˜ëŠ” í•¨ìˆ˜ ì‘ì„±
    [this.heap[a], this.heap[b]] = [this.heap[b], this.heap[a]];
  }
}

function dijkstra(road, N) {
  const heap = new MinHeap(); // ìš°ì„ ìˆœìœ„ í(í™)
  heap.push({ node: 1, cost: 0 }); // 1ë²ˆ ë§ˆì„ë¶€í„° ì‹œì‘

  const dist = [...Array(N + 1)].map(() => Infinity); // ê³„ì‚°í•˜ê¸° í¸í•˜ë„ë¡ N+1 ê¸¸ì´ë§Œí¼ ë¦¬ìŠ¤íŠ¸ ìƒì„±
  dist[1] = 0; // 1ë²ˆ ë§ˆì„ì€ ë¬´ì¡°ê±´ ê±°ë¦¬ê°€ 0

  while (!heap.isEmpty()) {
    // heapì´ ë¹„ì–´ìˆì§€ ì•Šë‹¤ë©´
    // costê°€ ê°€ì¥ ë‚®ì€ ì •ì ì„ ë½‘ëŠ”ë‹¤.
    const { node: current, cost: currentCost } = heap.pop();

    for (const [src, dest, cost] of road) {
      // ë£¨í”„ë¥¼ ëŒë©° ì‹œì‘ì , ë„ì°©ì , ë¹„ìš©ì„ êº¼ë‚¸ë‹¤
      const nextCost = cost + currentCost; // ë¹„ìš©

      // ì–‘ë°©í–¥ì„ ê³ ë ¤í•˜ì—¬ ì‘ì„±
      if (src === current && nextCost < dist[dest]) {
        // srcê°€ í˜„ì¬ ì„ íƒëœ ì •ì ì´ë©´ì„œ ëª©ì ì§€ê¹Œì§€ ë” ì €ë ´í•  ê²½ìš°
        dist[dest] = nextCost; // ê±°ë¦¬ë¥¼ ê°±ì‹ í•œë‹¤.
        heap.push({ node: dest, cost: nextCost }); // push
      } else if (dest == current && nextCost < dist[src]) {
        // destê°€ í˜„ì¬ ì„ íƒëœ ì •ì ì´ë©´ì„œ ëª©ì ì§€ê¹Œì§€ ë” ì €ë ´í•  ê²½ìš°
        dist[src] = nextCost; // ê±°ë¦¬ë¥¼ ê°±ì‹ í•œë‹¤.
        heap.push({ node: src, cost: nextCost }); // push
      }
    }
  }

  return dist; // 1ë²ˆ ë§ˆì„ë¶€í„° ê° ë§ˆì„ê¹Œì§€ì˜ ìµœë‹¨ ê±°ë¦¬
}

function solution(N, road, K) {
  const dist = dijkstra(road, N);
  return dist.filter(x => x <= K).length;
}
```
