# ìë™ ì™„ì„±

í¬í„¸ ë‹¤ìŒì—ì„œ ê²€ìƒ‰ì–´ ìë™ì™„ì„± ê¸°ëŠ¥ì„ ë„£ê³  ì‹¶ì€ ë¼ì´ì–¸ì€ í•œ ë²ˆ ì…ë ¥ëœ ë¬¸ìì—´ì„ í•™ìŠµí•´ì„œ ë‹¤ìŒ ì…ë ¥ ë•Œ í™œìš©í•˜ê³  ì‹¶ì–´ ì¡Œë‹¤. ì˜ˆë¥¼ ë“¤ì–´,Â `go`Â ê°€ í•œ ë²ˆ ì…ë ¥ë˜ì—ˆë‹¤ë©´, ë‹¤ìŒ ì‚¬ìš©ìëŠ”Â `g`Â ë§Œ ì…ë ¥í•´ë„Â `go`ë¥¼ ì¶”ì²œí•´ì£¼ë¯€ë¡œÂ `o`ë¥¼ ì…ë ¥í•  í•„ìš”ê°€ ì—†ì–´ì§„ë‹¤! ë‹¨, í•™ìŠµì— ì‚¬ìš©ëœ ë‹¨ì–´ë“¤ ì¤‘ ì•ë¶€ë¶„ì´ ê°™ì€ ê²½ìš°ì—ëŠ” ì–´ì©” ìˆ˜ ì—†ì´ ë‹¤ë¥¸ ë¬¸ìê°€ ë‚˜ì˜¬ ë•Œê¹Œì§€ ì…ë ¥ì„ í•´ì•¼ í•œë‹¤.

íš¨ê³¼ê°€ ì–¼ë§ˆë‚˜ ì¢‹ì„ì§€ ì•Œê³  ì‹¶ì€ ë¼ì´ì–¸ì€ í•™ìŠµëœ ë‹¨ì–´ë“¤ì„ ì°¾ì„ ë•Œ ëª‡ ê¸€ìë¥¼ ì…ë ¥í•´ì•¼ í•˜ëŠ”ì§€ ê¶ê¸ˆí•´ì¡Œë‹¤.

ì˜ˆë¥¼ ë“¤ì–´, í•™ìŠµëœ ë‹¨ì–´ë“¤ì´ ì•„ë˜ì™€ ê°™ì„ ë•Œ

`go
gone
guild`

- `go`ë¥¼ ì°¾ì„ ë•ŒÂ `go`ë¥¼ ëª¨ë‘ ì…ë ¥í•´ì•¼ í•œë‹¤.
- `gone`ì„ ì°¾ì„ ë•ŒÂ `gon`Â ê¹Œì§€ ì…ë ¥í•´ì•¼ í•œë‹¤. (`gon`ì´ ì…ë ¥ë˜ê¸° ì „ê¹Œì§€ëŠ”Â `go`Â ì¸ì§€Â `gone`ì¸ì§€ í™•ì‹ í•  ìˆ˜ ì—†ë‹¤.)
- `guild`ë¥¼ ì°¾ì„ ë•ŒëŠ”Â `gu`Â ê¹Œì§€ë§Œ ì…ë ¥í•˜ë©´Â `guild`ê°€ ì™„ì„±ëœë‹¤.

ì´ ê²½ìš° ì´ ì…ë ¥í•´ì•¼ í•  ë¬¸ìì˜ ìˆ˜ëŠ”Â `7`ì´ë‹¤.

ë¼ì´ì–¸ì„ ë„ì™€ ìœ„ì™€ ê°™ì´ ë¬¸ìì—´ì´ ì…ë ¥ìœ¼ë¡œ ì£¼ì–´ì§€ë©´ í•™ìŠµì„ ì‹œí‚¨ í›„, í•™ìŠµëœ ë‹¨ì–´ë“¤ì„ ìˆœì„œëŒ€ë¡œ ì°¾ì„ ë•Œ ëª‡ ê°œì˜ ë¬¸ìë¥¼ ì…ë ¥í•˜ë©´ ë˜ëŠ”ì§€ ê³„ì‚°í•˜ëŠ” í”„ë¡œê·¸ë¨ì„ ë§Œë“¤ì–´ë³´ì.

### ë¬¸ì œ ì¶”ìƒí™” â­

ë¬¸ì œ ì´ë¦„ë¶€í„° **ìë™ì™„ì„±**ì´ê¸° ë•Œë¬¸ì— ë°”ë¡œ `Trie`ë¥¼ ë– ì˜¬ë¦´ ìˆ˜ ìˆë‹¤. ê·¸ë¦¬ê³  ìë™ì™„ì„± ê¸°ëŠ¥ì´ ë˜ì–´ì•¼ ìµœì†Œ ì…ë ¥ ê¸€ìë¥¼ ì•Œ ìˆ˜ ìˆê¸°ì— ì´ ë¬¸ì œì—ì„œ `Trie`ê°€ ê°€ì¥ íš¨ìœ¨ì ì¸ ìë£Œêµ¬ì¡°ë¼ëŠ” ê²ƒì„ ì•Œ ìˆ˜ ìˆë‹¤.

### ì „ëµ ğŸ”§

`Trie` êµ¬ì¡°ë¥¼ ë§Œë“¤ë©´ì„œ í•˜ìœ„ì— ì–´ë–¤ ë¬¸ìë“¤ì´ ìˆëŠ”ì§€ ë¯¸ë¦¬ ì•Œì•„ì•¼ ì…€ ìˆ˜ ìˆë‹¤.

1. â€œgoâ€ë¥¼ ë„£ëŠ”ë‹¤.
    1. ë£¨íŠ¸ì˜ ìì‹ ë…¸ë“œë¡œ â€œgâ€ë¥¼ ì¶”ê°€í•œë‹¤. ì´ë•Œ â€œgâ€ ë…¸ë“œì— ë‹¨ì–´ê°€ ì¶”ê°€ë˜ì—ˆìŒì„ ì•Œë¦¬ê¸° ìœ„í•´ ì¹´ìš´íŒ…ì„ í•´ì¤€ë‹¤. (â€gâ€,1)
    2. â€œgâ€ì˜ ìì‹ ë…¸ë“œë¡œ â€œoâ€ë¥¼ ì¶”ê°€í•œë‹¤. ì´ë•Œ â€œoâ€ ë…¸ë“œì— ë‹¨ì–´ê°€ ì¶”ê°€ë˜ì—ˆìŒì„ ì•Œë¦¬ê¸° ìœ„í•´ ì¹´ìš´íŒ…ì„ í•´ì¤€ë‹¤. (â€oâ€,1)
2. â€œgoneâ€ì„ ë„£ëŠ”ë‹¤.
    1. ë£¨íŠ¸ì˜ ìì‹ ë…¸ë“œë¡œ â€œgâ€ë¥¼ ì¶”ê°€í•œë‹¤. ì´ë•Œ â€œgâ€ ë…¸ë“œì— ë‹¨ì–´ê°€ ì¶”ê°€ë˜ì—ˆìŒì„ ì•Œë¦¬ê¸° ìœ„í•´ ì¹´ìš´íŒ…ì„ í•´ì¤€ë‹¤. ì´ë¯¸ ë£¨íŠ¸ì˜ ìì‹ ë…¸ë“œì— â€œgâ€ê°€ ìˆê¸°ë•Œë¬¸ì— (â€gâ€,2)ê°€ ëœë‹¤.
    2. â€œgâ€ì˜ ìì‹ ë…¸ë“œë¡œ â€œoâ€ë¥¼ ì¶”ê°€í•œë‹¤. ì´ë•Œ â€œoâ€ê°€ ì¶”ê°€ë˜ì—ˆìŒì„ ì•Œë¦¬ê¸° ìœ„í•´ ì¹´ìš´íŒ…ì„ í•´ì¤€ë‹¤. â€œgâ€ë…¸ë“œì˜ ìì‹ ë…¸ë“œì— â€œoâ€ê°€ ìˆê¸°ë•Œë¬¸ì— (â€oâ€,2)ê°€ ëœë‹¤.
    3. â€œoâ€ì˜ ìì‹ ë…¸ë“œë¡œ â€œnâ€ì„ ì¶”ê°€í•œë‹¤. (â€nâ€,1)
    4. â€œnâ€ì˜ ìì‹ ë…¸ë“œë¡œ â€œeâ€ë¥¼ ì¶”ê°€í•œë‹¤. (â€eâ€,1)
3. â€œguildâ€ë¥¼ ë„£ëŠ”ë‹¤.
    
    â€¦
    

### êµ¬í˜„ ğŸ”¨

```jsx
class Node {
  constructor(value = '') {
    this.value = value;
    this.children = new Map();
    this.count = {};
  }
}

class Trie {
  constructor() {
    this.root = new Node();
  }

  insert(string) {
    let currentNode = this.root;

    for (let char of string) {
      if (!currentNode.children.get(char)) {
        currentNode.children.set(char, new Node(currentNode.value + char));
      }

      currentNode.count[char] = 1 + (currentNode.count[char] ?? 0);
      currentNode = currentNode.children.get(char);
    }
  }

  has(string) {
    let currentNode = this.root;
    let count = 0;

    for (let char of string) {
      count = count + 1;

      if (currentNode.count[char] === 1) {
        return [true, count];
      }

      currentNode = currentNode.children.get(char);
    }

    return [true, count];
  }
}

function solution(words) {
  const trie = new Trie();

  for (let word of words) {
    trie.insert(word);
  }

  const array = [];
  for (let word of words) {
    array.push(trie.has(word)[1]);
  }

  answer = array.reduce((a, b) => a + b, 0);

  return answer;
}

const words = ['go', 'gone', 'guild'];
console.log(solution(words));

```

```jsx
function makeTrie(words) {
  const root = {}; // ë¨¼ì € ë£¨íŠ¸ ë…¸ë“œë¥¼ ì„¤ì •í•  ë³€ìˆ˜ë¥¼ ë§Œë“ ë‹¤.
  for (const word of words) { // Trieë¥¼ êµ¬ì„±í•˜ê¸° ìœ„í•œ ë£¨í”„ë¥¼ ëŒë¦°ë‹¤.
    let current = root; // ë£¨í”„ë¶€í„° ì‹œì‘
    for (const letter of word) { // ë‹¨ì–´ì˜ ê¸€ìë¥¼ í•˜ë‚˜ì”© ì¶«ì¶œí•œ í›„
      if (!current[letter]) current[letter] = [0, {}]; // ê°’ì„ ë„£ëŠ”ë‹¤. ë¦¬ìŠ¤íŠ¸ì˜ ì²« ë²ˆì§¸ ê°’ì€ í•™ìŠµëœ ë‹¨ì–´ê°€ ëª‡ ê°œì¸ì§€ë¥¼ ì¹´ìš´íŒ…í•˜ê³  ë‘ ë²ˆì§¸ ê°’ì€ íŠ¸ë¦¬ êµ¬ì¡°ë¡œ ì´ìš©í•  ë…¸ë“œ ê°’ìœ¼ë¡œ ì‚¬ìš©í•œë‹¤.
      current[letter][0] = 1 + (current[letter][0] || 0); // ì¹´ìš´íŒ…ì„ ìœ„í•´ 1 ë”í•´ì¤€ë‹¤.
      current = current[letter][1]; // currentëŠ” letterì— í•´ë‹¹ë˜ëŠ” ë…¸ë“œë¡œ ì´ë™í•œë‹¤.
    }
  }

  return root; // ë°˜í™˜
}

function solution(words) {
  let answer = 0;
  const trie = makeTrie(words); // Trie ìë£Œêµ¬ì¡°ë¥¼ ë§Œë“¤ì–´ì¤€ë‹¤.

  for (const word of words) { // ì…ë ¥ë°›ì€ ìˆ˜ ë§Œí¼ ë£¨í”„
    let count = 0; // ì¹´ìš´íŒ…ì„ ìœ„í•œ ë³€ìˆ˜
    let current = trie; // ë£¨íŠ¸ë¶€í„° ì‹œì‘
    for (const [index, letter] of [...word].entries()) {
      count += 1;
      if (current[letter][0] <= 1) { // ë‹¨ì–´ê°€ í•˜ë‚˜ ì´í•˜ë¡œ ë‚¨ì„ ê²½ìš° ì¢…ë£Œ
        break;
      }
      current = current[letter][1]; // ë‹¤ìŒ ë…¸ë“œë¡œ ì´ë™
    }
    answer += count; // ì¹´ìš´íŒ…ì„ ë”í•´ì¤€ë‹¤
  }

  return answer; // ë°˜í™˜
}
```

### ì‹œí–‰ ì°©ì˜¤

ì‰½ê²Œ ì ‘ê·¼í–ˆì§€ë§Œ, ì‹œê°„ì´ ì˜¤ë˜ê±¸ë ¸ë‹¤. ì‹œê°í™” í•˜ëŠ” ëŠ¥ë ¥ì„ í‚¤ì›Œì•¼ê² ë‹¤.