# 그래프

그래프는 연결되어있는 원소간의 관계를 표현한 자료구조이다.
그래프는 연결할 객체를 나타내는 정점(Vertex)과 객체를 연결하는 간선(Edge)의 집합으로 구성된다.

### 그래프의 종류

1. 무방향 그래프 - 두 정점을 연결하는 간선에 방향이 없는 그래프이다.
2. 방향 그래프 - 두 정점을 연결하는 간선에 방향이 있는 그래프이다.
3. 완전 그래프 - 한 정점에서 다른 모든 정점과 연결되어 최대 간선을 갖는 그래프이다.

### 그래프의 용어

그래프에서 두 정점 Vi와 Vj가 연결되어 간선(Vi,Vj)가 있을 때, 두 정점 Vi와 Vj를 인접한다고 한다.

1. 차수 - 정점에 부속되어있는 간선의 수
2. 경로 - 정점 Vi에서 Vj까지 간선으로 연결된 정점을 순서대로 나열한 리스트
3. 경로 길이 - 경로를 구성하는 간선의 수

### 인접 행렬과 인접 리스트

그래프 관련 문제를 풀 때, 문제 상황을 그래프로 모델링한 후에 푸는것이 보편적이다. 모델링한 그래프의 연결관계를 나타내는 두 가지 방식으로 인접 행렬과 인접 리스트가있다.

1. 인접 행렬
2. 인접 리스트

### 인접 행렬

그래프의 연결관계를 2차원 배열로 나타내는 방식이다. 다음과 같이 표현한다.

`ad[i][j]` : 노드 i에서 노드j로 가는 간선이 있다면 해당 배열에 1을 아니면 0을 삽입한다.

 

### 인접 행렬의 장단점

인접 행렬은 구현이 쉽다는 장점이 있다. 노드 i와 j가 연결되어있는지 확인하기 위해선 `ad[i][j]`가 1인지 0인지만 확인하면 되기때문이다. 

하지만 노드 i에 연결된 모든 간선을 확인하기위해선 ad[i][1]부터 끝까지 확인해봐야한다는 단점이 있다.

### 구현(무방향 그래프)

문제를 풀 때 그래프에 대한 정보가 다음과 같은 정보가 주어진다.

1. 노드의 개수
2. 간선의 개수
3. 각 간선의 양끝 노드

```jsx
let v = 4;
let e = 5;

const arr = [[1,2],[1,3],[1,4],[2,3],[3,4]];

function graph(arr){
	// 간선의 개수만큼 연결시켜줘야한다.
	// 연결시킨다는것은 배열에 1을 넣는다는것
	// 무방향 그래프이기에 양쪽 다 처리

	// 정점의 개수가 4이기에 편의를 위해 5X5 배열을 만들자.
	const graph = Array(v+1).fill(0).map(()=>Array(v+1).fill(0));

	// arr을 순회하면서 연결시키자.
	for(let [i,j] of arr){
		graph[i][j] = 1;
		graph[j][i] = 1;
	}

	return graph;
}

```

### 인접 리스트

인접 리스트는 그래프의 연결 관계를 배열에 링크드 리스트처럼 연결되어있는 정점을 이어붙이는것이다.

인접 리스트는 실제로 연결된 노드들에 대한 정보만 저장하기에 원소의 개수의 합이 간선의 개수와 같다는것이다. 

하지만 노드 i와 노드 j가 연결되어있는지 알고싶다면 ad[i]에 있는 배열을 모두 순회하면서 j를 가지는지 확인해야한다.

그래프가 간단할때, 정점이 적을때는 인접 행렬이 유리하지만, 많아지면 인접리스트로 구현하는것이 메모리 차원에서도 좋다.